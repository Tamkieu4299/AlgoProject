{"ast":null,"code":"const getAllNodes = grid => {\n  const result = [];\n  for (const row of grid) {\n    for (const col of row) {\n      result.push(col);\n    }\n  }\n  return result;\n};\nexport function Dijkstras(grid, start, end) {\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getAllNodes(grid);\n  start.distance = 0;\n  while (unvisitedNodes.length !== 0) {\n    const current = unvisitedNodes.sort((n1, n2) => n1.distance - n2.distance).shift();\n    if (current.isWall) continue;\n    if (current.distance === Infinity) return visitedNodesInOrder;\n    current.isVisited = true;\n    visitedNodesInOrder.push(current);\n    if (current === end) return visitedNodesInOrder;\n    let neighbors = [];\n    const {\n      col,\n      row\n    } = current;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    for (const neighbor of neighbors) {\n      neighbor.distance = current.distance + 1;\n      neighbor.previousNode = current;\n    }\n  }\n}\n_c = Dijkstras;\nexport function getNodesInShortestPathOrder_Dijkstras(end) {\n  const nodesInShortestPathOrder = [];\n  let current = end;\n  while (current) {\n    nodesInShortestPathOrder.unshift(current);\n    current = current.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\nvar _c;\n$RefreshReg$(_c, \"Dijkstras\");","map":{"version":3,"names":["getAllNodes","grid","result","row","col","push","Dijkstras","start","end","visitedNodesInOrder","unvisitedNodes","distance","length","current","sort","n1","n2","shift","isWall","Infinity","isVisited","neighbors","filter","neighbor","previousNode","getNodesInShortestPathOrder_Dijkstras","nodesInShortestPathOrder","unshift"],"sources":["C:/Users/Lenovo/Desktop/workplace/projects/algo_projects/mazevisualize/src/Algo/Dijkstras.jsx"],"sourcesContent":["const getAllNodes = (grid) => {\r\n    const result = [];\r\n    for (const row of grid) {\r\n        for (const col of row) {\r\n            result.push(col)\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function Dijkstras(grid, start, end) {\r\n    const visitedNodesInOrder = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    start.distance = 0;\r\n\r\n    while (unvisitedNodes.length !== 0) {\r\n        const current = unvisitedNodes.sort((n1, n2) => n1.distance - n2.distance).shift();\r\n        if (current.isWall) continue;\r\n        if (current.distance === Infinity) return visitedNodesInOrder;\r\n        current.isVisited = true;\r\n        visitedNodesInOrder.push(current);\r\n        if (current === end) return visitedNodesInOrder;\r\n\r\n        let neighbors = [];\r\n        const { col, row } = current;\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n\r\n        for (const neighbor of neighbors) {\r\n            neighbor.distance = current.distance + 1;\r\n            neighbor.previousNode = current;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder_Dijkstras(end) {\r\n    const nodesInShortestPathOrder = [];\r\n    let current = end;\r\n    while (current) {\r\n        nodesInShortestPathOrder.unshift(current);\r\n        current = current.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"],"mappings":"AAAA,MAAMA,WAAW,GAAIC,IAAI,IAAK;EAC1B,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMC,GAAG,IAAIF,IAAI,EAAE;IACpB,KAAK,MAAMG,GAAG,IAAID,GAAG,EAAE;MACnBD,MAAM,CAACG,IAAI,CAACD,GAAG,CAAC;IACpB;EACJ;EACA,OAAOF,MAAM;AACjB,CAAC;AAED,OAAO,SAASI,SAAS,CAACL,IAAI,EAAEM,KAAK,EAAEC,GAAG,EAAE;EACxC,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,MAAMC,cAAc,GAAGV,WAAW,CAACC,IAAI,CAAC;EACxCM,KAAK,CAACI,QAAQ,GAAG,CAAC;EAElB,OAAOD,cAAc,CAACE,MAAM,KAAK,CAAC,EAAE;IAChC,MAAMC,OAAO,GAAGH,cAAc,CAACI,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAACJ,QAAQ,GAAGK,EAAE,CAACL,QAAQ,CAAC,CAACM,KAAK,EAAE;IAClF,IAAIJ,OAAO,CAACK,MAAM,EAAE;IACpB,IAAIL,OAAO,CAACF,QAAQ,KAAKQ,QAAQ,EAAE,OAAOV,mBAAmB;IAC7DI,OAAO,CAACO,SAAS,GAAG,IAAI;IACxBX,mBAAmB,CAACJ,IAAI,CAACQ,OAAO,CAAC;IACjC,IAAIA,OAAO,KAAKL,GAAG,EAAE,OAAOC,mBAAmB;IAE/C,IAAIY,SAAS,GAAG,EAAE;IAClB,MAAM;MAAEjB,GAAG;MAAED;IAAI,CAAC,GAAGU,OAAO;IAC5B,IAAIV,GAAG,GAAG,CAAC,EAAEkB,SAAS,CAAChB,IAAI,CAACJ,IAAI,CAACE,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;IAC/C,IAAID,GAAG,GAAGF,IAAI,CAACW,MAAM,GAAG,CAAC,EAAES,SAAS,CAAChB,IAAI,CAACJ,IAAI,CAACE,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;IAC7D,IAAIA,GAAG,GAAG,CAAC,EAAEiB,SAAS,CAAChB,IAAI,CAACJ,IAAI,CAACE,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;IAC/C,IAAIA,GAAG,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACW,MAAM,GAAG,CAAC,EAAES,SAAS,CAAChB,IAAI,CAACJ,IAAI,CAACE,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;IAChEiB,SAAS,GAAGA,SAAS,CAACC,MAAM,CAACC,QAAQ,IAAI,CAACA,QAAQ,CAACH,SAAS,CAAC;IAE7D,KAAK,MAAMG,QAAQ,IAAIF,SAAS,EAAE;MAC9BE,QAAQ,CAACZ,QAAQ,GAAGE,OAAO,CAACF,QAAQ,GAAG,CAAC;MACxCY,QAAQ,CAACC,YAAY,GAAGX,OAAO;IACnC;EACJ;AACJ;AAAC,KA1BeP,SAAS;AA4BzB,OAAO,SAASmB,qCAAqC,CAACjB,GAAG,EAAE;EACvD,MAAMkB,wBAAwB,GAAG,EAAE;EACnC,IAAIb,OAAO,GAAGL,GAAG;EACjB,OAAOK,OAAO,EAAE;IACZa,wBAAwB,CAACC,OAAO,CAACd,OAAO,CAAC;IACzCA,OAAO,GAAGA,OAAO,CAACW,YAAY;EAClC;EACA,OAAOE,wBAAwB;AACnC;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
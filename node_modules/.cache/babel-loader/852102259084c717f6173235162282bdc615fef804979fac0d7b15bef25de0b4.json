{"ast":null,"code":"let shortLength = Infinity;\n// export function DFS(grid, start, end) {\n//     const visitedNodesInOrder = [];\n//     length+=1;\n//     let stack = []\n//     stack.push(start);\n//     start.distance = 0;\n\n//     while (stack.length > 0) {\n//         const current = stack.pop();\n//         if (current.isWall) continue;\n//         if (current.distance === Infinity) return visitedNodesInOrder;\n//         if (current.isVisited) continue;\n\n//         current.isVisited = true;\n//         visitedNodesInOrder.push(current);\n//         if (current === end) return visitedNodesInOrder;\n\n//         let neighbors = [];\n//         const { col, row } = current;\n//         if (row > 0) neighbors.push(grid[row - 1][col]);\n//         if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n//         if (col > 0) neighbors.push(grid[row][col - 1]);\n//         if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n//         neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n//         neighbors.map(neighbor => stack.push(neighbor))\n//         for (const neighbor of neighbors) {\n//             neighbor.distance = current.distance + 1;\n//             neighbor.previousNode = current;\n//         }\n//     }\n// }\nexport function DFS(grid, start, end, visitedNodesInOrder) {\n  if (start.distance > shortLength) return;\n  if (start.isWall) return;\n  if (start.isVisited) return;\n  if (start === end) {\n    shortLength = start.distance;\n    return;\n  }\n  start.isVisited = true;\n  visitedNodesInOrder.push(start);\n  let neighbors = [];\n  const {\n    col,\n    row\n  } = start;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n  for (const neighbor of neighbors) {\n    neighbor.distance = start.distance + 1;\n    neighbor.previousNode = start;\n  }\n  neighbors.map(neighbor => DFS(grid, neighbor, end, visitedNodesInOrder));\n}\n_c = DFS;\nexport function getNodesInShortestPathOrder_DFS(end) {\n  const nodesInShortestPathOrder = [];\n  let current = end;\n  while (current) {\n    nodesInShortestPathOrder.unshift(current);\n    current = current.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\nvar _c;\n$RefreshReg$(_c, \"DFS\");","map":{"version":3,"names":["shortLength","Infinity","DFS","grid","start","end","visitedNodesInOrder","distance","isWall","isVisited","push","neighbors","col","row","length","filter","neighbor","previousNode","map","getNodesInShortestPathOrder_DFS","nodesInShortestPathOrder","current","unshift"],"sources":["C:/Users/Lenovo/Desktop/workplace/projects/algo_projects/mazevisualize/src/Algo/Dfs.jsx"],"sourcesContent":["let shortLength = Infinity\r\n// export function DFS(grid, start, end) {\r\n//     const visitedNodesInOrder = [];\r\n//     length+=1;\r\n//     let stack = []\r\n//     stack.push(start);\r\n//     start.distance = 0;\r\n\r\n//     while (stack.length > 0) {\r\n//         const current = stack.pop();\r\n//         if (current.isWall) continue;\r\n//         if (current.distance === Infinity) return visitedNodesInOrder;\r\n//         if (current.isVisited) continue;\r\n\r\n//         current.isVisited = true;\r\n//         visitedNodesInOrder.push(current);\r\n//         if (current === end) return visitedNodesInOrder;\r\n\r\n//         let neighbors = [];\r\n//         const { col, row } = current;\r\n//         if (row > 0) neighbors.push(grid[row - 1][col]);\r\n//         if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n//         if (col > 0) neighbors.push(grid[row][col - 1]);\r\n//         if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n//         neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n//         neighbors.map(neighbor => stack.push(neighbor))\r\n//         for (const neighbor of neighbors) {\r\n//             neighbor.distance = current.distance + 1;\r\n//             neighbor.previousNode = current;\r\n//         }\r\n//     }\r\n// }\r\nexport function DFS(grid, start, end, visitedNodesInOrder) {\r\n    if(start.distance > shortLength) return;\r\n    if (start.isWall) return;\r\n    if (start.isVisited) return;\r\n    if(start === end){\r\n        shortLength = start.distance;\r\n        return;\r\n    }\r\n    start.isVisited = true\r\n    visitedNodesInOrder.push(start);\r\n    let neighbors = [];\r\n    const { col, row } = start;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n    for (const neighbor of neighbors) {\r\n        neighbor.distance = start.distance + 1;\r\n        neighbor.previousNode = start;\r\n    }\r\n    neighbors.map(neighbor => DFS(grid, neighbor, end, visitedNodesInOrder))\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder_DFS(end) {\r\n    const nodesInShortestPathOrder = [];\r\n    let current = end;\r\n    while (current) {\r\n        nodesInShortestPathOrder.unshift(current);\r\n        current = current.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"],"mappings":"AAAA,IAAIA,WAAW,GAAGC,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,mBAAmB,EAAE;EACvD,IAAGF,KAAK,CAACG,QAAQ,GAAGP,WAAW,EAAE;EACjC,IAAII,KAAK,CAACI,MAAM,EAAE;EAClB,IAAIJ,KAAK,CAACK,SAAS,EAAE;EACrB,IAAGL,KAAK,KAAKC,GAAG,EAAC;IACbL,WAAW,GAAGI,KAAK,CAACG,QAAQ;IAC5B;EACJ;EACAH,KAAK,CAACK,SAAS,GAAG,IAAI;EACtBH,mBAAmB,CAACI,IAAI,CAACN,KAAK,CAAC;EAC/B,IAAIO,SAAS,GAAG,EAAE;EAClB,MAAM;IAAEC,GAAG;IAAEC;EAAI,CAAC,GAAGT,KAAK;EAC1B,IAAIS,GAAG,GAAG,CAAC,EAAEF,SAAS,CAACD,IAAI,CAACP,IAAI,CAACU,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC/C,IAAIC,GAAG,GAAGV,IAAI,CAACW,MAAM,GAAG,CAAC,EAAEH,SAAS,CAACD,IAAI,CAACP,IAAI,CAACU,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC7D,IAAIA,GAAG,GAAG,CAAC,EAAED,SAAS,CAACD,IAAI,CAACP,IAAI,CAACU,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAC/C,IAAIA,GAAG,GAAGT,IAAI,CAAC,CAAC,CAAC,CAACW,MAAM,GAAG,CAAC,EAAEH,SAAS,CAACD,IAAI,CAACP,IAAI,CAACU,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAChED,SAAS,GAAGA,SAAS,CAACI,MAAM,CAACC,QAAQ,IAAI,CAACA,QAAQ,CAACP,SAAS,CAAC;EAC7D,KAAK,MAAMO,QAAQ,IAAIL,SAAS,EAAE;IAC9BK,QAAQ,CAACT,QAAQ,GAAGH,KAAK,CAACG,QAAQ,GAAG,CAAC;IACtCS,QAAQ,CAACC,YAAY,GAAGb,KAAK;EACjC;EACAO,SAAS,CAACO,GAAG,CAACF,QAAQ,IAAId,GAAG,CAACC,IAAI,EAAEa,QAAQ,EAAEX,GAAG,EAAEC,mBAAmB,CAAC,CAAC;AAC5E;AAAC,KAtBeJ,GAAG;AAyBnB,OAAO,SAASiB,+BAA+B,CAACd,GAAG,EAAE;EACjD,MAAMe,wBAAwB,GAAG,EAAE;EACnC,IAAIC,OAAO,GAAGhB,GAAG;EACjB,OAAOgB,OAAO,EAAE;IACZD,wBAAwB,CAACE,OAAO,CAACD,OAAO,CAAC;IACzCA,OAAO,GAAGA,OAAO,CAACJ,YAAY;EAClC;EACA,OAAOG,wBAAwB;AACnC;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
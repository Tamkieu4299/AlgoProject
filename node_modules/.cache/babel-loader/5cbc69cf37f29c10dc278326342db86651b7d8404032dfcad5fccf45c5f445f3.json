{"ast":null,"code":"let length = 0;\nlet shortLength = Infinity;\n// export function DFS(grid, start, end) {\n//     const visitedNodesInOrder = [];\n//     length+=1;\n//     let stack = []\n//     stack.push(start);\n//     start.distance = 0;\n\n//     while (stack.length > 0) {\n//         const current = stack.pop();\n//         if (current.isWall) continue;\n//         if (current.distance === Infinity) return visitedNodesInOrder;\n//         if (current.isVisited) continue;\n\n//         current.isVisited = true;\n//         visitedNodesInOrder.push(current);\n//         if (current === end) return visitedNodesInOrder;\n\n//         let neighbors = [];\n//         const { col, row } = current;\n//         if (row > 0) neighbors.push(grid[row - 1][col]);\n//         if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n//         if (col > 0) neighbors.push(grid[row][col - 1]);\n//         if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n//         neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n//         neighbors.map(neighbor => stack.push(neighbor))\n//         for (const neighbor of neighbors) {\n//             neighbor.distance = current.distance + 1;\n//             neighbor.previousNode = current;\n//         }\n//     }\n// }\nexport function DFS(grid, start, end, visitedNodesInOrder) {\n  length += 1;\n  if (length > shortLength) return;\n  if (start.isWall) return;\n  if (start.isVisited) return;\n  if (start === end) {\n    shortLength = length;\n    return;\n  }\n  start.isVisited = true;\n  visitedNodesInOrder.push(start);\n  let neighbors = [];\n  const {\n    col,\n    row\n  } = start;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n  neighbors.map(neighbor => DFS(grid, neighbor, end, visitedNodesInOrder));\n  length -= 1;\n}\n_c = DFS;\nexport function getNodesInShortestPathOrder_DFS(end) {\n  const nodesInShortestPathOrder = [];\n  let current = end;\n  while (current) {\n    nodesInShortestPathOrder.unshift(current);\n    current = current.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\nvar _c;\n$RefreshReg$(_c, \"DFS\");","map":{"version":3,"names":["length","shortLength","Infinity","DFS","grid","start","end","visitedNodesInOrder","isWall","isVisited","push","neighbors","col","row","filter","neighbor","map","getNodesInShortestPathOrder_DFS","nodesInShortestPathOrder","current","unshift","previousNode"],"sources":["C:/Users/Lenovo/Desktop/workplace/projects/algo_projects/mazevisualize/src/Algo/Dfs.jsx"],"sourcesContent":["let length=0;\r\nlet shortLength = Infinity\r\n// export function DFS(grid, start, end) {\r\n//     const visitedNodesInOrder = [];\r\n//     length+=1;\r\n//     let stack = []\r\n//     stack.push(start);\r\n//     start.distance = 0;\r\n\r\n//     while (stack.length > 0) {\r\n//         const current = stack.pop();\r\n//         if (current.isWall) continue;\r\n//         if (current.distance === Infinity) return visitedNodesInOrder;\r\n//         if (current.isVisited) continue;\r\n\r\n//         current.isVisited = true;\r\n//         visitedNodesInOrder.push(current);\r\n//         if (current === end) return visitedNodesInOrder;\r\n\r\n//         let neighbors = [];\r\n//         const { col, row } = current;\r\n//         if (row > 0) neighbors.push(grid[row - 1][col]);\r\n//         if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n//         if (col > 0) neighbors.push(grid[row][col - 1]);\r\n//         if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n//         neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n//         neighbors.map(neighbor => stack.push(neighbor))\r\n//         for (const neighbor of neighbors) {\r\n//             neighbor.distance = current.distance + 1;\r\n//             neighbor.previousNode = current;\r\n//         }\r\n//     }\r\n// }\r\nexport function DFS(grid, start, end, visitedNodesInOrder) {\r\n    length+=1;\r\n    if(length > shortLength) return;\r\n    if (start.isWall) return;\r\n    if (start.isVisited) return;\r\n    if(start === end){\r\n        shortLength = length;\r\n        return;\r\n    }\r\n    start.isVisited = true\r\n    visitedNodesInOrder.push(start);\r\n    let neighbors = [];\r\n    const { col, row } = start;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n    neighbors.map(neighbor => DFS(grid, neighbor, end, visitedNodesInOrder))\r\n    length-=1;\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder_DFS(end) {\r\n    const nodesInShortestPathOrder = [];\r\n    let current = end;\r\n    while (current) {\r\n        nodesInShortestPathOrder.unshift(current);\r\n        current = current.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"],"mappings":"AAAA,IAAIA,MAAM,GAAC,CAAC;AACZ,IAAIC,WAAW,GAAGC,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,mBAAmB,EAAE;EACvDP,MAAM,IAAE,CAAC;EACT,IAAGA,MAAM,GAAGC,WAAW,EAAE;EACzB,IAAII,KAAK,CAACG,MAAM,EAAE;EAClB,IAAIH,KAAK,CAACI,SAAS,EAAE;EACrB,IAAGJ,KAAK,KAAKC,GAAG,EAAC;IACbL,WAAW,GAAGD,MAAM;IACpB;EACJ;EACAK,KAAK,CAACI,SAAS,GAAG,IAAI;EACtBF,mBAAmB,CAACG,IAAI,CAACL,KAAK,CAAC;EAC/B,IAAIM,SAAS,GAAG,EAAE;EAClB,MAAM;IAAEC,GAAG;IAAEC;EAAI,CAAC,GAAGR,KAAK;EAC1B,IAAIQ,GAAG,GAAG,CAAC,EAAEF,SAAS,CAACD,IAAI,CAACN,IAAI,CAACS,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC/C,IAAIC,GAAG,GAAGT,IAAI,CAACJ,MAAM,GAAG,CAAC,EAAEW,SAAS,CAACD,IAAI,CAACN,IAAI,CAACS,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC7D,IAAIA,GAAG,GAAG,CAAC,EAAED,SAAS,CAACD,IAAI,CAACN,IAAI,CAACS,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAC/C,IAAIA,GAAG,GAAGR,IAAI,CAAC,CAAC,CAAC,CAACJ,MAAM,GAAG,CAAC,EAAEW,SAAS,CAACD,IAAI,CAACN,IAAI,CAACS,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAChED,SAAS,GAAGA,SAAS,CAACG,MAAM,CAACC,QAAQ,IAAI,CAACA,QAAQ,CAACN,SAAS,CAAC;EAC7DE,SAAS,CAACK,GAAG,CAACD,QAAQ,IAAIZ,GAAG,CAACC,IAAI,EAAEW,QAAQ,EAAET,GAAG,EAAEC,mBAAmB,CAAC,CAAC;EACxEP,MAAM,IAAE,CAAC;AACb;AAAC,KApBeG,GAAG;AAuBnB,OAAO,SAASc,+BAA+B,CAACX,GAAG,EAAE;EACjD,MAAMY,wBAAwB,GAAG,EAAE;EACnC,IAAIC,OAAO,GAAGb,GAAG;EACjB,OAAOa,OAAO,EAAE;IACZD,wBAAwB,CAACE,OAAO,CAACD,OAAO,CAAC;IACzCA,OAAO,GAAGA,OAAO,CAACE,YAAY;EAClC;EACA,OAAOH,wBAAwB;AACnC;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
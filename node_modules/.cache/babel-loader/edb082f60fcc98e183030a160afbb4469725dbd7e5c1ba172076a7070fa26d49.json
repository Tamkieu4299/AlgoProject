{"ast":null,"code":"export function DFS(grid, start, end) {\n  const visitedNodesInOrder = [];\n  let stack = [];\n  stack.push(start);\n  start.distance = 0;\n  let shortLength = Infinity;\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (current.isWall) continue;\n    if (current.distance > shortLength) continue;\n    if (current.distance === Infinity) return visitedNodesInOrder;\n    if (current.isVisited) continue;\n    current.isVisited = true;\n    visitedNodesInOrder.push(current);\n    if (current === end) {\n      shortLength = Math.min(current.distance, shortLength);\n      continue;\n    }\n    let neighbors = [];\n    const {\n      col,\n      row\n    } = current;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n    neighbors.map(neighbor => stack.push(neighbor));\n    for (const neighbor of neighbors) {\n      neighbor.distance = current.distance + 1;\n      neighbor.previousNode = current;\n    }\n  }\n  return visitedNodesInOrder;\n}\n// export function DFS(grid, start, end, visitedNodesInOrder) {\n//     if(start.distance > shortLength) return;\n//     if (start.isWall) return;\n//     if (start.isVisited) return;\n//     if(start === end){\n//         shortLength = start.distance;\n//         return;\n//     }\n//     start.isVisited = true\n//     visitedNodesInOrder.push(start);\n//     let neighbors = [];\n//     const { col, row } = start;\n//     if (row > 0) neighbors.push(grid[row - 1][col]);\n//     if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n//     if (col > 0) neighbors.push(grid[row][col - 1]);\n//     if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n//     neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\n//     for (const neighbor of neighbors) {\n//         neighbor.distance = start.distance + 1;\n//         neighbor.previousNode = start;\n//     }\n//     neighbors.map(neighbor => DFS(grid, neighbor, end, visitedNodesInOrder))\n// }\n_c = DFS;\nexport function getNodesInShortestPathOrder_DFS(end) {\n  const nodesInShortestPathOrder = [];\n  let current = end;\n  while (current) {\n    nodesInShortestPathOrder.unshift(current);\n    current = current.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\nvar _c;\n$RefreshReg$(_c, \"DFS\");","map":{"version":3,"names":["DFS","grid","start","end","visitedNodesInOrder","stack","push","distance","shortLength","Infinity","length","current","pop","isWall","isVisited","Math","min","neighbors","col","row","filter","neighbor","map","previousNode","getNodesInShortestPathOrder_DFS","nodesInShortestPathOrder","unshift"],"sources":["C:/Users/Lenovo/Desktop/workplace/projects/algo_projects/mazevisualize/src/Algo/Dfs.jsx"],"sourcesContent":["export function DFS(grid, start, end) {\r\n    const visitedNodesInOrder = [];\r\n    let stack = []\r\n    stack.push(start);\r\n    start.distance = 0;\r\n    let shortLength = Infinity\r\n\r\n    while (stack.length > 0) {\r\n        const current = stack.pop();\r\n        if (current.isWall) continue;\r\n        if(current.distance>shortLength) continue;\r\n        if (current.distance === Infinity) return visitedNodesInOrder;\r\n        if (current.isVisited) continue;\r\n\r\n        current.isVisited = true;\r\n        visitedNodesInOrder.push(current);\r\n        if(current === end){\r\n            shortLength = Math.min(current.distance,shortLength);\r\n            continue;\r\n        }\r\n\r\n        let neighbors = [];\r\n        const { col, row } = current;\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        neighbors.map(neighbor => stack.push(neighbor))\r\n        for (const neighbor of neighbors) {\r\n            neighbor.distance = current.distance + 1;\r\n            neighbor.previousNode = current;\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n// export function DFS(grid, start, end, visitedNodesInOrder) {\r\n//     if(start.distance > shortLength) return;\r\n//     if (start.isWall) return;\r\n//     if (start.isVisited) return;\r\n//     if(start === end){\r\n//         shortLength = start.distance;\r\n//         return;\r\n//     }\r\n//     start.isVisited = true\r\n//     visitedNodesInOrder.push(start);\r\n//     let neighbors = [];\r\n//     const { col, row } = start;\r\n//     if (row > 0) neighbors.push(grid[row - 1][col]);\r\n//     if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n//     if (col > 0) neighbors.push(grid[row][col - 1]);\r\n//     if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n//     neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n//     for (const neighbor of neighbors) {\r\n//         neighbor.distance = start.distance + 1;\r\n//         neighbor.previousNode = start;\r\n//     }\r\n//     neighbors.map(neighbor => DFS(grid, neighbor, end, visitedNodesInOrder))\r\n// }\r\n\r\n\r\nexport function getNodesInShortestPathOrder_DFS(end) {\r\n    const nodesInShortestPathOrder = [];\r\n    let current = end;\r\n    while (current) {\r\n        nodesInShortestPathOrder.unshift(current);\r\n        current = current.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"],"mappings":"AAAA,OAAO,SAASA,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAE;EAClC,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,IAAIC,KAAK,GAAG,EAAE;EACdA,KAAK,CAACC,IAAI,CAACJ,KAAK,CAAC;EACjBA,KAAK,CAACK,QAAQ,GAAG,CAAC;EAClB,IAAIC,WAAW,GAAGC,QAAQ;EAE1B,OAAOJ,KAAK,CAACK,MAAM,GAAG,CAAC,EAAE;IACrB,MAAMC,OAAO,GAAGN,KAAK,CAACO,GAAG,EAAE;IAC3B,IAAID,OAAO,CAACE,MAAM,EAAE;IACpB,IAAGF,OAAO,CAACJ,QAAQ,GAACC,WAAW,EAAE;IACjC,IAAIG,OAAO,CAACJ,QAAQ,KAAKE,QAAQ,EAAE,OAAOL,mBAAmB;IAC7D,IAAIO,OAAO,CAACG,SAAS,EAAE;IAEvBH,OAAO,CAACG,SAAS,GAAG,IAAI;IACxBV,mBAAmB,CAACE,IAAI,CAACK,OAAO,CAAC;IACjC,IAAGA,OAAO,KAAKR,GAAG,EAAC;MACfK,WAAW,GAAGO,IAAI,CAACC,GAAG,CAACL,OAAO,CAACJ,QAAQ,EAACC,WAAW,CAAC;MACpD;IACJ;IAEA,IAAIS,SAAS,GAAG,EAAE;IAClB,MAAM;MAAEC,GAAG;MAAEC;IAAI,CAAC,GAAGR,OAAO;IAC5B,IAAIQ,GAAG,GAAG,CAAC,EAAEF,SAAS,CAACX,IAAI,CAACL,IAAI,CAACkB,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;IAC/C,IAAIC,GAAG,GAAGlB,IAAI,CAACS,MAAM,GAAG,CAAC,EAAEO,SAAS,CAACX,IAAI,CAACL,IAAI,CAACkB,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;IAC7D,IAAIA,GAAG,GAAG,CAAC,EAAED,SAAS,CAACX,IAAI,CAACL,IAAI,CAACkB,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;IAC/C,IAAIA,GAAG,GAAGjB,IAAI,CAAC,CAAC,CAAC,CAACS,MAAM,GAAG,CAAC,EAAEO,SAAS,CAACX,IAAI,CAACL,IAAI,CAACkB,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;IAChED,SAAS,GAAGA,SAAS,CAACG,MAAM,CAACC,QAAQ,IAAI,CAACA,QAAQ,CAACP,SAAS,CAAC;IAC7DG,SAAS,CAACK,GAAG,CAACD,QAAQ,IAAIhB,KAAK,CAACC,IAAI,CAACe,QAAQ,CAAC,CAAC;IAC/C,KAAK,MAAMA,QAAQ,IAAIJ,SAAS,EAAE;MAC9BI,QAAQ,CAACd,QAAQ,GAAGI,OAAO,CAACJ,QAAQ,GAAG,CAAC;MACxCc,QAAQ,CAACE,YAAY,GAAGZ,OAAO;IACnC;EACJ;EACA,OAAOP,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,KA1DgBJ,GAAG;AA6DnB,OAAO,SAASwB,+BAA+B,CAACrB,GAAG,EAAE;EACjD,MAAMsB,wBAAwB,GAAG,EAAE;EACnC,IAAId,OAAO,GAAGR,GAAG;EACjB,OAAOQ,OAAO,EAAE;IACZc,wBAAwB,CAACC,OAAO,CAACf,OAAO,CAAC;IACzCA,OAAO,GAAGA,OAAO,CAACY,YAAY;EAClC;EACA,OAAOE,wBAAwB;AACnC;AAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}